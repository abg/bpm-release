// Copyright (C) 2020-Present CloudFoundry.org Foundation, Inc. All rights reserved.
//
// This program and the accompanying materials are made available under
// the terms of the under the Apache License, Version 2.0 (the "License‚Äù);
// you may not use this file except in compliance with the License.
//
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: bpm/runc/lifecycle (interfaces: UserFinder,CommandRunner,RuncAdapter,RuncClient)

// Package mock_lifecycle is a generated GoMock package.
package mock_lifecycle

import (
	config "bpm/config"
	client "bpm/runc/client"
	io "io"
	os "os"
	exec "os/exec"
	reflect "reflect"

	lager "code.cloudfoundry.org/lager/v3"
	gomock "github.com/golang/mock/gomock"
	specs "github.com/opencontainers/runtime-spec/specs-go"
)

// MockUserFinder is a mock of UserFinder interface.
type MockUserFinder struct {
	ctrl     *gomock.Controller
	recorder *MockUserFinderMockRecorder
}

// MockUserFinderMockRecorder is the mock recorder for MockUserFinder.
type MockUserFinderMockRecorder struct {
	mock *MockUserFinder
}

// NewMockUserFinder creates a new mock instance.
func NewMockUserFinder(ctrl *gomock.Controller) *MockUserFinder {
	mock := &MockUserFinder{ctrl: ctrl}
	mock.recorder = &MockUserFinderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserFinder) EXPECT() *MockUserFinderMockRecorder {
	return m.recorder
}

// Lookup mocks base method.
func (m *MockUserFinder) Lookup(arg0 string) (specs.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lookup", arg0)
	ret0, _ := ret[0].(specs.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lookup indicates an expected call of Lookup.
func (mr *MockUserFinderMockRecorder) Lookup(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lookup", reflect.TypeOf((*MockUserFinder)(nil).Lookup), arg0)
}

// MockCommandRunner is a mock of CommandRunner interface.
type MockCommandRunner struct {
	ctrl     *gomock.Controller
	recorder *MockCommandRunnerMockRecorder
}

// MockCommandRunnerMockRecorder is the mock recorder for MockCommandRunner.
type MockCommandRunnerMockRecorder struct {
	mock *MockCommandRunner
}

// NewMockCommandRunner creates a new mock instance.
func NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner {
	mock := &MockCommandRunner{ctrl: ctrl}
	mock.recorder = &MockCommandRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockCommandRunner) Run(arg0 *exec.Cmd) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockCommandRunnerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockCommandRunner)(nil).Run), arg0)
}

// MockRuncAdapter is a mock of RuncAdapter interface.
type MockRuncAdapter struct {
	ctrl     *gomock.Controller
	recorder *MockRuncAdapterMockRecorder
}

// MockRuncAdapterMockRecorder is the mock recorder for MockRuncAdapter.
type MockRuncAdapterMockRecorder struct {
	mock *MockRuncAdapter
}

// NewMockRuncAdapter creates a new mock instance.
func NewMockRuncAdapter(ctrl *gomock.Controller) *MockRuncAdapter {
	mock := &MockRuncAdapter{ctrl: ctrl}
	mock.recorder = &MockRuncAdapterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuncAdapter) EXPECT() *MockRuncAdapterMockRecorder {
	return m.recorder
}

// BuildSpec mocks base method.
func (m *MockRuncAdapter) BuildSpec(arg0 lager.Logger, arg1 *config.BPMConfig, arg2 *config.ProcessConfig, arg3 specs.User) (specs.Spec, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildSpec", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(specs.Spec)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildSpec indicates an expected call of BuildSpec.
func (mr *MockRuncAdapterMockRecorder) BuildSpec(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildSpec", reflect.TypeOf((*MockRuncAdapter)(nil).BuildSpec), arg0, arg1, arg2, arg3)
}

// CreateJobPrerequisites mocks base method.
func (m *MockRuncAdapter) CreateJobPrerequisites(arg0 *config.BPMConfig, arg1 *config.ProcessConfig, arg2 specs.User) (*os.File, *os.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJobPrerequisites", arg0, arg1, arg2)
	ret0, _ := ret[0].(*os.File)
	ret1, _ := ret[1].(*os.File)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateJobPrerequisites indicates an expected call of CreateJobPrerequisites.
func (mr *MockRuncAdapterMockRecorder) CreateJobPrerequisites(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJobPrerequisites", reflect.TypeOf((*MockRuncAdapter)(nil).CreateJobPrerequisites), arg0, arg1, arg2)
}

// MockRuncClient is a mock of RuncClient interface.
type MockRuncClient struct {
	ctrl     *gomock.Controller
	recorder *MockRuncClientMockRecorder
}

// MockRuncClientMockRecorder is the mock recorder for MockRuncClient.
type MockRuncClientMockRecorder struct {
	mock *MockRuncClient
}

// NewMockRuncClient creates a new mock instance.
func NewMockRuncClient(ctrl *gomock.Controller) *MockRuncClient {
	mock := &MockRuncClient{ctrl: ctrl}
	mock.recorder = &MockRuncClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuncClient) EXPECT() *MockRuncClientMockRecorder {
	return m.recorder
}

// ContainerState mocks base method.
func (m *MockRuncClient) ContainerState(arg0 string) (*specs.State, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ContainerState", arg0)
	ret0, _ := ret[0].(*specs.State)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ContainerState indicates an expected call of ContainerState.
func (mr *MockRuncClientMockRecorder) ContainerState(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContainerState", reflect.TypeOf((*MockRuncClient)(nil).ContainerState), arg0)
}

// CreateBundle mocks base method.
func (m *MockRuncClient) CreateBundle(arg0 string, arg1 specs.Spec, arg2 specs.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBundle", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBundle indicates an expected call of CreateBundle.
func (mr *MockRuncClientMockRecorder) CreateBundle(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBundle", reflect.TypeOf((*MockRuncClient)(nil).CreateBundle), arg0, arg1, arg2)
}

// DeleteContainer mocks base method.
func (m *MockRuncClient) DeleteContainer(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteContainer", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteContainer indicates an expected call of DeleteContainer.
func (mr *MockRuncClientMockRecorder) DeleteContainer(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteContainer", reflect.TypeOf((*MockRuncClient)(nil).DeleteContainer), arg0)
}

// DestroyBundle mocks base method.
func (m *MockRuncClient) DestroyBundle(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyBundle", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DestroyBundle indicates an expected call of DestroyBundle.
func (mr *MockRuncClientMockRecorder) DestroyBundle(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyBundle", reflect.TypeOf((*MockRuncClient)(nil).DestroyBundle), arg0)
}

// Exec mocks base method.
func (m *MockRuncClient) Exec(arg0, arg1 string, arg2 io.Reader, arg3, arg4 io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockRuncClientMockRecorder) Exec(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRuncClient)(nil).Exec), arg0, arg1, arg2, arg3, arg4)
}

// ListContainers mocks base method.
func (m *MockRuncClient) ListContainers() ([]client.ContainerState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListContainers")
	ret0, _ := ret[0].([]client.ContainerState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListContainers indicates an expected call of ListContainers.
func (mr *MockRuncClientMockRecorder) ListContainers() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListContainers", reflect.TypeOf((*MockRuncClient)(nil).ListContainers))
}

// RunContainer mocks base method.
func (m *MockRuncClient) RunContainer(arg0, arg1, arg2 string, arg3 bool, arg4, arg5 io.Writer) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunContainer", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunContainer indicates an expected call of RunContainer.
func (mr *MockRuncClientMockRecorder) RunContainer(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunContainer", reflect.TypeOf((*MockRuncClient)(nil).RunContainer), arg0, arg1, arg2, arg3, arg4, arg5)
}

// SignalContainer mocks base method.
func (m *MockRuncClient) SignalContainer(arg0 string, arg1 client.Signal) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignalContainer", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SignalContainer indicates an expected call of SignalContainer.
func (mr *MockRuncClientMockRecorder) SignalContainer(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignalContainer", reflect.TypeOf((*MockRuncClient)(nil).SignalContainer), arg0, arg1)
}
